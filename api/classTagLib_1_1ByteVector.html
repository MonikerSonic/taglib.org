---
layout: api
title: "TagLib::ByteVector Class Reference (TagLib)"
header: "1.11 (TagLib::ByteVector Class Reference)"
---
<!-- Generated by Doxygen 1.8.9.1 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTagLib.html">TagLib</a></li><li class="navelem"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classTagLib_1_1ByteVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TagLib::ByteVector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A byte vector.  
 <a href="classTagLib_1_1ByteVector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="tbytevector_8h_source.html">tbytevector.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for TagLib::ByteVector:</div>
<div class="dyncontent">
<div class="center"><img src="classTagLib_1_1ByteVector__coll__graph.png" border="0" usemap="#TagLib_1_1ByteVector_coll__map" alt="Collaboration graph"/></div>
<map name="TagLib_1_1ByteVector_coll__map" id="TagLib_1_1ByteVector_coll__map">
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af6e5b2614dacfc049b5b6e32063d4aa1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#af6e5b2614dacfc049b5b6e32063d4aa1">ByteVector</a> ()</td></tr>
<tr class="separator:af6e5b2614dacfc049b5b6e32063d4aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8da8ca7d1cff849c684bb9c2189602"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2c8da8ca7d1cff849c684bb9c2189602">ByteVector</a> (unsigned int <a class="el" href="classTagLib_1_1ByteVector.html#a956f911990decdc396d9d400787687a8">size</a>, char value=0)</td></tr>
<tr class="separator:a2c8da8ca7d1cff849c684bb9c2189602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613e5467e1b582775f98eed1e2f6c1ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a613e5467e1b582775f98eed1e2f6c1ef">ByteVector</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>
<tr class="separator:a613e5467e1b582775f98eed1e2f6c1ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb5a6eef9127e15e0379dc246cdc56b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aedb5a6eef9127e15e0379dc246cdc56b">ByteVector</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v, unsigned int offset, unsigned int length)</td></tr>
<tr class="separator:aedb5a6eef9127e15e0379dc246cdc56b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa286e2ae6447e55e85ef855838d10c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa286e2ae6447e55e85ef855838d10c96">ByteVector</a> (char c)</td></tr>
<tr class="separator:aa286e2ae6447e55e85ef855838d10c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69d28f4aeb8c4410ec3b69cdf30faeb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ae69d28f4aeb8c4410ec3b69cdf30faeb">ByteVector</a> (const char *<a class="el" href="classTagLib_1_1ByteVector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>, unsigned int length)</td></tr>
<tr class="separator:ae69d28f4aeb8c4410ec3b69cdf30faeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3cd4cd25e6b8fbd6a795005478b08e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa3cd4cd25e6b8fbd6a795005478b08e0">ByteVector</a> (const char *<a class="el" href="classTagLib_1_1ByteVector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>)</td></tr>
<tr class="separator:aa3cd4cd25e6b8fbd6a795005478b08e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b45e9a86728313ddef12a037acc73d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a34b45e9a86728313ddef12a037acc73d">~ByteVector</a> ()</td></tr>
<tr class="separator:a34b45e9a86728313ddef12a037acc73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf18390eaa358bd59450113189edc71e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#abf18390eaa358bd59450113189edc71e">setData</a> (const char *<a class="el" href="classTagLib_1_1ByteVector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>, unsigned int length)</td></tr>
<tr class="separator:abf18390eaa358bd59450113189edc71e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a5128d1503ddaf6e6f780ce4eeb184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#af9a5128d1503ddaf6e6f780ce4eeb184">setData</a> (const char *<a class="el" href="classTagLib_1_1ByteVector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>)</td></tr>
<tr class="separator:af9a5128d1503ddaf6e6f780ce4eeb184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55d40ed1e9b9749e3895c845f1f26901"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a> ()</td></tr>
<tr class="separator:a55d40ed1e9b9749e3895c845f1f26901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe39991f59ce978639ef48400b0891b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#affe39991f59ce978639ef48400b0891b">data</a> () const </td></tr>
<tr class="separator:affe39991f59ce978639ef48400b0891b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73f960ab69d900f0d02ff2407600c154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a73f960ab69d900f0d02ff2407600c154">mid</a> (unsigned int index, unsigned int length=0xffffffff) const </td></tr>
<tr class="separator:a73f960ab69d900f0d02ff2407600c154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3782d2c5b32e0d6c825c727528a527"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a7a3782d2c5b32e0d6c825c727528a527">at</a> (unsigned int index) const </td></tr>
<tr class="separator:a7a3782d2c5b32e0d6c825c727528a527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176c463cd5439db2c07da48e1b53b3bb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a176c463cd5439db2c07da48e1b53b3bb">find</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, unsigned int offset=0, int byteAlign=1) const </td></tr>
<tr class="separator:a176c463cd5439db2c07da48e1b53b3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56bbb8e76178d6edad1af21ba61602ce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a56bbb8e76178d6edad1af21ba61602ce">find</a> (char c, unsigned int offset=0, int byteAlign=1) const </td></tr>
<tr class="separator:a56bbb8e76178d6edad1af21ba61602ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accef5714ce2752588291ddf179e7f9f3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#accef5714ce2752588291ddf179e7f9f3">rfind</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, unsigned int offset=0, int byteAlign=1) const </td></tr>
<tr class="separator:accef5714ce2752588291ddf179e7f9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa495ddda77639c75e121ddf3c8441fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aaa495ddda77639c75e121ddf3c8441fc">containsAt</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, unsigned int offset, unsigned int patternOffset=0, unsigned int patternLength=0xffffffff) const </td></tr>
<tr class="separator:aaa495ddda77639c75e121ddf3c8441fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f330306a73bbd23d89f7c14a2126456"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a5f330306a73bbd23d89f7c14a2126456">startsWith</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr class="separator:a5f330306a73bbd23d89f7c14a2126456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68505e709c3cc3061ca0de7a04251f46"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a68505e709c3cc3061ca0de7a04251f46">endsWith</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr class="separator:a68505e709c3cc3061ca0de7a04251f46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2c71ba84454616e1310e6dc12f8aa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#adf2c71ba84454616e1310e6dc12f8aa8">replace</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern, const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;with)</td></tr>
<tr class="separator:adf2c71ba84454616e1310e6dc12f8aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9d03a684dbba770e2871a2dfe1d55a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#afe9d03a684dbba770e2871a2dfe1d55a">endsWithPartialMatch</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;pattern) const </td></tr>
<tr class="separator:afe9d03a684dbba770e2871a2dfe1d55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff38e54fa184e9cf0c77182db200a6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aff38e54fa184e9cf0c77182db200a6e4">append</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>
<tr class="separator:aff38e54fa184e9cf0c77182db200a6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a68a92f04cdffc1cb2fe67845079649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3a68a92f04cdffc1cb2fe67845079649">append</a> (char c)</td></tr>
<tr class="separator:a3a68a92f04cdffc1cb2fe67845079649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2e95380834f3a55d49df208befe88c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2e2e95380834f3a55d49df208befe88c">clear</a> ()</td></tr>
<tr class="separator:a2e2e95380834f3a55d49df208befe88c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956f911990decdc396d9d400787687a8"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a956f911990decdc396d9d400787687a8">size</a> () const </td></tr>
<tr class="separator:a956f911990decdc396d9d400787687a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa055ecfae9837099c1857c7466bed0a1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa055ecfae9837099c1857c7466bed0a1">resize</a> (unsigned int <a class="el" href="classTagLib_1_1ByteVector.html#a956f911990decdc396d9d400787687a8">size</a>, char padding=0)</td></tr>
<tr class="separator:aa055ecfae9837099c1857c7466bed0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99848a9fbcb7b39e16866a881e2b115f"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a99848a9fbcb7b39e16866a881e2b115f">begin</a> ()</td></tr>
<tr class="separator:a99848a9fbcb7b39e16866a881e2b115f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab4c8b26244d1efc6f392062a3146e41"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aab4c8b26244d1efc6f392062a3146e41">begin</a> () const </td></tr>
<tr class="separator:aab4c8b26244d1efc6f392062a3146e41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a1f28d1a51f7351733f2ef22090c34"><td class="memItemLeft" align="right" valign="top">Iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a53a1f28d1a51f7351733f2ef22090c34">end</a> ()</td></tr>
<tr class="separator:a53a1f28d1a51f7351733f2ef22090c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc7a47ae21af8e3a02be6346c078f2b8"><td class="memItemLeft" align="right" valign="top">ConstIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#acc7a47ae21af8e3a02be6346c078f2b8">end</a> () const </td></tr>
<tr class="separator:acc7a47ae21af8e3a02be6346c078f2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b3cc8251bedb5bbb3c917d5b30ea93"><td class="memItemLeft" align="right" valign="top">ReverseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a01b3cc8251bedb5bbb3c917d5b30ea93">rbegin</a> ()</td></tr>
<tr class="separator:a01b3cc8251bedb5bbb3c917d5b30ea93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea66336e4fcd37c0a35dedc4e3f171c"><td class="memItemLeft" align="right" valign="top">ConstReverseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2ea66336e4fcd37c0a35dedc4e3f171c">rbegin</a> () const </td></tr>
<tr class="separator:a2ea66336e4fcd37c0a35dedc4e3f171c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18a15e7cab535f22c8107992c66789d7"><td class="memItemLeft" align="right" valign="top">ReverseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a18a15e7cab535f22c8107992c66789d7">rend</a> ()</td></tr>
<tr class="separator:a18a15e7cab535f22c8107992c66789d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13b347466e2603aaee43415e426a90f"><td class="memItemLeft" align="right" valign="top">ConstReverseIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ab13b347466e2603aaee43415e426a90f">rend</a> () const </td></tr>
<tr class="separator:ab13b347466e2603aaee43415e426a90f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ab3712f32591b5af95f3fe43421f704"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3ab3712f32591b5af95f3fe43421f704">isNull</a> () const </td></tr>
<tr class="separator:a3ab3712f32591b5af95f3fe43421f704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4db491627843669c3d26263f18ef72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#abf4db491627843669c3d26263f18ef72">isEmpty</a> () const </td></tr>
<tr class="separator:abf4db491627843669c3d26263f18ef72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5020af00ccf9818ee9c916dfb4d99b21"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a5020af00ccf9818ee9c916dfb4d99b21">checksum</a> () const </td></tr>
<tr class="separator:a5020af00ccf9818ee9c916dfb4d99b21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8334ff02c963635668cda49410af83ce"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a8334ff02c963635668cda49410af83ce">toUInt</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a8334ff02c963635668cda49410af83ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991a4bece604122c267ccf0022ecfd3c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a991a4bece604122c267ccf0022ecfd3c">toUInt</a> (unsigned int offset, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a991a4bece604122c267ccf0022ecfd3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec14950e616c3fc1b248294f6bc4871"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#abec14950e616c3fc1b248294f6bc4871">toUInt</a> (unsigned int offset, unsigned int length, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:abec14950e616c3fc1b248294f6bc4871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792be96ea5c9edb1d1eb9e987d0f0b1d"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a792be96ea5c9edb1d1eb9e987d0f0b1d">toShort</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a792be96ea5c9edb1d1eb9e987d0f0b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a7e6c2e922e3c4c0df3fd8524a95c26"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a4a7e6c2e922e3c4c0df3fd8524a95c26">toShort</a> (unsigned int offset, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a4a7e6c2e922e3c4c0df3fd8524a95c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa504bf38f98c782647ea46fbe7c9dc5c"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aa504bf38f98c782647ea46fbe7c9dc5c">toUShort</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:aa504bf38f98c782647ea46fbe7c9dc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298aa3d114d418de4cf193804526c7a3"><td class="memItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a298aa3d114d418de4cf193804526c7a3">toUShort</a> (unsigned int offset, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a298aa3d114d418de4cf193804526c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a398ca4acfe99175547dd239a2ed83730"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a398ca4acfe99175547dd239a2ed83730">toLongLong</a> (bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:a398ca4acfe99175547dd239a2ed83730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae66ba7ba54a1f9aa30a00c2e5ca2ed"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#abae66ba7ba54a1f9aa30a00c2e5ca2ed">toLongLong</a> (unsigned int offset, bool mostSignificantByteFirst=true) const </td></tr>
<tr class="separator:abae66ba7ba54a1f9aa30a00c2e5ca2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a2142280a5633589915778f54b037a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad6a2142280a5633589915778f54b037a">toFloat32LE</a> (size_t offset) const </td></tr>
<tr class="separator:ad6a2142280a5633589915778f54b037a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecc3152b830815587e276308b513791"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a8ecc3152b830815587e276308b513791">toFloat32BE</a> (size_t offset) const </td></tr>
<tr class="separator:a8ecc3152b830815587e276308b513791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20fea3031e4293fcc798841cf72e0371"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a20fea3031e4293fcc798841cf72e0371">toFloat64LE</a> (size_t offset) const </td></tr>
<tr class="separator:a20fea3031e4293fcc798841cf72e0371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0faf408571471f54fc23014ee0b45ac7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a0faf408571471f54fc23014ee0b45ac7">toFloat64BE</a> (size_t offset) const </td></tr>
<tr class="separator:a0faf408571471f54fc23014ee0b45ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ea32224af2025c6d5ae618e4bd2b6a"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a12ea32224af2025c6d5ae618e4bd2b6a">toFloat80LE</a> (size_t offset) const </td></tr>
<tr class="separator:a12ea32224af2025c6d5ae618e4bd2b6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55140a56e23aafd8628209b7a18f3cb7"><td class="memItemLeft" align="right" valign="top">long double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a55140a56e23aafd8628209b7a18f3cb7">toFloat80BE</a> (size_t offset) const </td></tr>
<tr class="separator:a55140a56e23aafd8628209b7a18f3cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec096b29dc0f9222ca393692fae128a"><td class="memItemLeft" align="right" valign="top">const char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a2ec096b29dc0f9222ca393692fae128a">operator[]</a> (int index) const </td></tr>
<tr class="separator:a2ec096b29dc0f9222ca393692fae128a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c078f5864c875eb49a0e900336191e2"><td class="memItemLeft" align="right" valign="top">char &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a6c078f5864c875eb49a0e900336191e2">operator[]</a> (int index)</td></tr>
<tr class="separator:a6c078f5864c875eb49a0e900336191e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e891841a6c5259b177498a19a91c758"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a9e891841a6c5259b177498a19a91c758">operator==</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a9e891841a6c5259b177498a19a91c758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3918f3327686bc80a6022bf66fb86124"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a3918f3327686bc80a6022bf66fb86124">operator!=</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a3918f3327686bc80a6022bf66fb86124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ae63d46b0a9ddd6971c40502cb7835f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a0ae63d46b0a9ddd6971c40502cb7835f">operator==</a> (const char *s) const </td></tr>
<tr class="separator:a0ae63d46b0a9ddd6971c40502cb7835f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0167694c169d832fa0b1012a5d62d89c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a0167694c169d832fa0b1012a5d62d89c">operator!=</a> (const char *s) const </td></tr>
<tr class="separator:a0167694c169d832fa0b1012a5d62d89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a264ff435cb7f79bd93ccdb1ba4d5c52f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a264ff435cb7f79bd93ccdb1ba4d5c52f">operator&lt;</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a264ff435cb7f79bd93ccdb1ba4d5c52f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3f661ccc7cf8309089e9b3a284d3bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a5c3f661ccc7cf8309089e9b3a284d3bc">operator&gt;</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a5c3f661ccc7cf8309089e9b3a284d3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5de1892f12726bb4d50276abd8f64edc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a5de1892f12726bb4d50276abd8f64edc">operator+</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v) const </td></tr>
<tr class="separator:a5de1892f12726bb4d50276abd8f64edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac612d7f38571456c5f0083e07df554cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ac612d7f38571456c5f0083e07df554cd">operator=</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>
<tr class="separator:ac612d7f38571456c5f0083e07df554cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a8204c1556dee0a7f330962b8587381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a4a8204c1556dee0a7f330962b8587381">operator=</a> (char c)</td></tr>
<tr class="separator:a4a8204c1556dee0a7f330962b8587381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5947f410bee90e1cd36a0dd931113d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aba5947f410bee90e1cd36a0dd931113d">operator=</a> (const char *<a class="el" href="classTagLib_1_1ByteVector.html#a55d40ed1e9b9749e3895c845f1f26901">data</a>)</td></tr>
<tr class="separator:aba5947f410bee90e1cd36a0dd931113d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76dc335731ccb8ef2894ff1b7cdec014"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a76dc335731ccb8ef2894ff1b7cdec014">swap</a> (<a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;v)</td></tr>
<tr class="separator:a76dc335731ccb8ef2894ff1b7cdec014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9839e48c11619907ad618a4d7399e76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ae9839e48c11619907ad618a4d7399e76">toHex</a> () const </td></tr>
<tr class="separator:ae9839e48c11619907ad618a4d7399e76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396653f8c540621a0803ef4fb9ecc771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a396653f8c540621a0803ef4fb9ecc771">toBase64</a> () const </td></tr>
<tr class="separator:a396653f8c540621a0803ef4fb9ecc771"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8b8cc9274056ef65cdcfe026843cbfb8"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt</a> (unsigned int value, bool mostSignificantByteFirst=true)</td></tr>
<tr class="separator:a8b8cc9274056ef65cdcfe026843cbfb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162543bf4b280468a677799686178522"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort</a> (short value, bool mostSignificantByteFirst=true)</td></tr>
<tr class="separator:a162543bf4b280468a677799686178522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b81a576453f38fb816294f1e77a76d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a51b81a576453f38fb816294f1e77a76d">fromLongLong</a> (long long value, bool mostSignificantByteFirst=true)</td></tr>
<tr class="separator:a51b81a576453f38fb816294f1e77a76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75e0045d245950a0b1e73f79bc3b6f7d"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a75e0045d245950a0b1e73f79bc3b6f7d">fromFloat32LE</a> (float value)</td></tr>
<tr class="separator:a75e0045d245950a0b1e73f79bc3b6f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8776da15f1e921a9643a4b10c39ddec"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ad8776da15f1e921a9643a4b10c39ddec">fromFloat32BE</a> (float value)</td></tr>
<tr class="separator:ad8776da15f1e921a9643a4b10c39ddec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545dd80c5cff59a070b804d3d2bcc979"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a545dd80c5cff59a070b804d3d2bcc979">fromFloat64LE</a> (double value)</td></tr>
<tr class="separator:a545dd80c5cff59a070b804d3d2bcc979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86ed6c1ddef60bd2a1b3c099fba1982"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#ab86ed6c1ddef60bd2a1b3c099fba1982">fromFloat64BE</a> (double value)</td></tr>
<tr class="separator:ab86ed6c1ddef60bd2a1b3c099fba1982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c77c48df4fd1096aa174ef09a938bbc"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a0c77c48df4fd1096aa174ef09a938bbc">fromCString</a> (const char *s, unsigned int length=0xffffffff)</td></tr>
<tr class="separator:a0c77c48df4fd1096aa174ef09a938bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258b37359217aacf0c494a192129589c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a258b37359217aacf0c494a192129589c">fromBase64</a> (const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;)</td></tr>
<tr class="separator:a258b37359217aacf0c494a192129589c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7593a608427eb6f855c4dc48558ad8a4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a7593a608427eb6f855c4dc48558ad8a4">null</a></td></tr>
<tr class="separator:a7593a608427eb6f855c4dc48558ad8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aed0573f25ee917a40d6cd242b3115ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#aed0573f25ee917a40d6cd242b3115ae0">detach</a> ()</td></tr>
<tr class="separator:aed0573f25ee917a40d6cd242b3115ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a36db251bf327d8f00dcee07367fd7cd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="taglib__export_8h.html#a869a58b518ef871f14a9b4ccfe86ecfb">TAGLIB_EXPORT</a> std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTagLib_1_1ByteVector.html#a36db251bf327d8f00dcee07367fd7cd5">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classTagLib_1_1ByteVector.html">TagLib::ByteVector</a> &amp;v)</td></tr>
<tr class="separator:a36db251bf327d8f00dcee07367fd7cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A byte vector. </p>
<p>This class provides a byte vector with some methods that are useful for tagging purposes. Many of the search functions are tailored to what is useful for finding tag related patterns in a data array. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af6e5b2614dacfc049b5b6e32063d4aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an empty byte vector. </p>

</div>
</div>
<a class="anchor" id="a2c8da8ca7d1cff849c684bb9c2189602"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a vector of size <em>size</em> with all values set to <em>value</em> by default. </p>

</div>
</div>
<a class="anchor" id="a613e5467e1b582775f98eed1e2f6c1ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that is a copy of <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="aedb5a6eef9127e15e0379dc246cdc56b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that is a copy of <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="aa286e2ae6447e55e85ef855838d10c96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that contains <em>c</em>. </p>

</div>
</div>
<a class="anchor" id="ae69d28f4aeb8c4410ec3b69cdf30faeb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that copies <em>data</em> for up to <em>length</em> bytes. </p>

</div>
</div>
<a class="anchor" id="aa3cd4cd25e6b8fbd6a795005478b08e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TagLib::ByteVector::ByteVector </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a byte vector that copies <em>data</em> up to the first null byte. This is particularly useful for constructing byte arrays from string constants.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if <em>data</em> is not null terminated. </dd></dl>

</div>
</div>
<a class="anchor" id="a34b45e9a86728313ddef12a037acc73d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TagLib::ByteVector::~ByteVector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> instance. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aff38e54fa184e9cf0c77182db200a6e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::append </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends <em>v</em> to the end of the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a>. </p>

</div>
</div>
<a class="anchor" id="a3a68a92f04cdffc1cb2fe67845079649"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::append </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Appends <em>c</em> to the end of the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a>. </p>

</div>
</div>
<a class="anchor" id="a7a3782d2c5b32e0d6c825c727528a527"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char TagLib::ByteVector::at </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This essentially performs the same as <a class="el" href="classTagLib_1_1ByteVector.html#a2ec096b29dc0f9222ca393692fae128a">operator[]()</a>, but instead of causing a runtime error if the index is out of bounds, it will return a null byte. </p>

</div>
</div>
<a class="anchor" id="a99848a9fbcb7b39e16866a881e2b115f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an Iterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="aab4c8b26244d1efc6f392062a3146e41"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstIterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="a5020af00ccf9818ee9c916dfb4d99b21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TagLib::ByteVector::checksum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a CRC checksum of the byte vector's data.</p>
<dl class="section note"><dt>Note</dt><dd>This uses an uncommon variant of CRC32 specializes in <a class="el" href="namespaceTagLib_1_1Ogg.html" title="A namespace for the classes used by Ogg-based metadata files. ">Ogg</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a2e2e95380834f3a55d49df208befe88c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the data. </p>

</div>
</div>
<a class="anchor" id="aaa495ddda77639c75e121ddf3c8441fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::containsAt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>patternOffset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>patternLength</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks to see if the vector contains the <em>pattern</em> starting at position <em>offset</em>. Optionally, if you only want to search for part of the pattern you can specify an offset within the pattern to start from. Also, you can specify to only check for the first <em>patternLength</em> bytes of <em>pattern</em> with the <em>patternLength</em> argument. </p>

</div>
</div>
<a class="anchor" id="a55d40ed1e9b9749e3895c845f1f26901"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* TagLib::ByteVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the internal data structure.</p>
<dl class="section warning"><dt>Warning</dt><dd>Care should be taken when modifying this data structure as it is easy to corrupt the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> when doing so. Specifically, while the data may be changed, its length may not be. </dd></dl>

</div>
</div>
<a class="anchor" id="affe39991f59ce978639ef48400b0891b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TagLib::ByteVector::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the internal data structure which may not be modified. </p>

</div>
</div>
<a class="anchor" id="aed0573f25ee917a40d6cd242b3115ae0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TagLib::ByteVector::detach </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a53a1f28d1a51f7351733f2ef22090c34"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Iterator TagLib::ByteVector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an Iterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="acc7a47ae21af8e3a02be6346c078f2b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstIterator TagLib::ByteVector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstIterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="a68505e709c3cc3061ca0de7a04251f46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::endsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vector ends with <em>pattern</em>. </p>

</div>
</div>
<a class="anchor" id="afe9d03a684dbba770e2871a2dfe1d55a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::endsWithPartialMatch </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks for a partial match of <em>pattern</em> at the end of the vector. It returns the offset of the partial match within the vector, or -1 if the pattern is not found. This method is particularly useful when searching for patterns that start in one vector and end in another. When combined with <a class="el" href="classTagLib_1_1ByteVector.html#a5f330306a73bbd23d89f7c14a2126456">startsWith()</a> it can be used to find a pattern that overlaps two buffers.</p>
<dl class="section note"><dt>Note</dt><dd>This will not match the complete pattern at the end of the string; use <a class="el" href="classTagLib_1_1ByteVector.html#a68505e709c3cc3061ca0de7a04251f46">endsWith()</a> for that. </dd></dl>

</div>
</div>
<a class="anchor" id="a176c463cd5439db2c07da48e1b53b3bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> for <em>pattern</em> starting at <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a class="anchor" id="a56bbb8e76178d6edad1af21ba61602ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::find </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the char for <em>c</em> starting at <em>offset</em> and returns the offset. Returns <em>-1</em> if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a class="anchor" id="a258b37359217aacf0c494a192129589c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromBase64 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decodes the base64 encoded byte vector. </p>

</div>
</div>
<a class="anchor" id="a0c77c48df4fd1096aa174ef09a938bbc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromCString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> based on the CString <em>s</em>. </p>

</div>
</div>
<a class="anchor" id="ad8776da15f1e921a9643a4b10c39ddec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromFloat32BE </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 4 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em> as an IEEE754 32-bit big-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a75e0045d245950a0b1e73f79bc3b6f7d">fromFloat32LE()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a75e0045d245950a0b1e73f79bc3b6f7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromFloat32LE </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 4 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em> as an IEEE754 32-bit little-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#ad8776da15f1e921a9643a4b10c39ddec">fromFloat32BE()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab86ed6c1ddef60bd2a1b3c099fba1982"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromFloat64BE </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em> as an IEEE754 64-bit big-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a545dd80c5cff59a070b804d3d2bcc979">fromFloat64LE()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a545dd80c5cff59a070b804d3d2bcc979"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromFloat64LE </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em> as an IEEE754 64-bit little-endian floating point number.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#ab86ed6c1ddef60bd2a1b3c099fba1982">fromFloat64BE()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a51b81a576453f38fb816294f1e77a76d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromLongLong </td>
          <td>(</td>
          <td class="paramtype">long long&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 8 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a398ca4acfe99175547dd239a2ed83730">toLongLong()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a162543bf4b280468a677799686178522"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromShort </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 2 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 01 == 0x0001 == 1, if false, $01 00 == 0x0100 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a792be96ea5c9edb1d1eb9e987d0f0b1d">toShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8b8cc9274056ef65cdcfe026843cbfb8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::fromUInt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a 4 byte <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> based on <em>value</em>. If <em>mostSignificantByteFirst</em> is true, then this will operate left to right in building the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a>. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8334ff02c963635668cda49410af83ce">toUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abf4db491627843669c3d26263f18ef72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> is empty.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a956f911990decdc396d9d400787687a8">size()</a> </dd>
<dd>
<a class="el" href="classTagLib_1_1ByteVector.html#a3ab3712f32591b5af95f3fe43421f704">isNull()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3ab3712f32591b5af95f3fe43421f704"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::isNull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vector is null.</p>
<dl class="section note"><dt>Note</dt><dd>A vector may be empty without being null. So do not use this method to check if the vector is empty.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#abf4db491627843669c3d26263f18ef72">isEmpty()</a></dd></dl>

</div>
</div>
<a class="anchor" id="a73f960ab69d900f0d02ff2407600c154"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::mid </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em> = <code>0xffffffff</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a byte vector made up of the bytes starting at <em>index</em> and for <em>length</em> bytes. If <em>length</em> is not specified it will return the bytes from <em>index</em> to the end of the vector. </p>

</div>
</div>
<a class="anchor" id="a3918f3327686bc80a6022bf66fb86124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> and <em>v</em> are not equal. </p>

</div>
</div>
<a class="anchor" id="a0167694c169d832fa0b1012a5d62d89c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator!= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> and the null terminated C string <em>s</em> do not contain the same data. </p>

</div>
</div>
<a class="anchor" id="a5de1892f12726bb4d50276abd8f64edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector that is <em>v</em> appended to this vector. </p>

</div>
</div>
<a class="anchor" id="a264ff435cb7f79bd93ccdb1ba4d5c52f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> is less than <em>v</em>. The value of the vectors is determined by evaluating the character from left to right, and in the event one vector is a superset of the other, the size is used. </p>

</div>
</div>
<a class="anchor" id="ac612d7f38571456c5f0083e07df554cd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a4a8204c1556dee0a7f330962b8587381"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies a byte <em>c</em>. </p>

</div>
</div>
<a class="anchor" id="aba5947f410bee90e1cd36a0dd931113d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::operator= </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies <em>data</em> up to the first null byte.</p>
<dl class="section warning"><dt>Warning</dt><dd>The behavior is undefined if <em>data</em> is not null terminated. </dd></dl>

</div>
</div>
<a class="anchor" id="a9e891841a6c5259b177498a19a91c758"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> and <em>v</em> are equal. </p>

</div>
</div>
<a class="anchor" id="a0ae63d46b0a9ddd6971c40502cb7835f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator== </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> and the null terminated C string <em>s</em> contain the same data. </p>

</div>
</div>
<a class="anchor" id="a5c3f661ccc7cf8309089e9b3a284d3bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if this <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> is greater than <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a2ec096b29dc0f9222ca393692fae128a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char&amp; TagLib::ByteVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const reference to the byte at <em>index</em>. </p>

</div>
</div>
<a class="anchor" id="a6c078f5864c875eb49a0e900336191e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char&amp; TagLib::ByteVector::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a reference to the byte at <em>index</em>. </p>

</div>
</div>
<a class="anchor" id="a01b3cc8251bedb5bbb3c917d5b30ea93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReverseIterator TagLib::ByteVector::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ReverseIterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="a2ea66336e4fcd37c0a35dedc4e3f171c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstReverseIterator TagLib::ByteVector::rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstReverseIterator that points to the front of the vector. </p>

</div>
</div>
<a class="anchor" id="a18a15e7cab535f22c8107992c66789d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ReverseIterator TagLib::ByteVector::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ReverseIterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="ab13b347466e2603aaee43415e426a90f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ConstReverseIterator TagLib::ByteVector::rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a ConstReverseIterator that points to the back of the vector. </p>

</div>
</div>
<a class="anchor" id="adf2c71ba84454616e1310e6dc12f8aa8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::replace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>with</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces <em>pattern</em> with <em>with</em> and returns a reference to the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> after the operation. This <em>does</em> modify the vector. </p>

</div>
</div>
<a class="anchor" id="aa055ecfae9837099c1857c7466bed0a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::resize </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padding</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Resize the vector to <em>size</em>. If the vector is currently less than <em>size</em>, pad the remaining spaces with <em>padding</em>. Returns a reference to the resized vector. </p>

</div>
</div>
<a class="anchor" id="accef5714ce2752588291ddf179e7f9f3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TagLib::ByteVector::rfind </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>byteAlign</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> for <em>pattern</em> starting from either the end of the vector or <em>offset</em> and returns the offset. Returns -1 if the pattern was not found. If <em>byteAlign</em> is specified the pattern will only be matched if it starts on a byte divisible by <em>byteAlign</em> (starting from <em>offset</em>). </p>

</div>
</div>
<a class="anchor" id="abf18390eaa358bd59450113189edc71e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::setData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data for the byte array using the first <em>length</em> bytes of <em>data</em> </p>

</div>
</div>
<a class="anchor" id="af9a5128d1503ddaf6e6f780ce4eeb184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a>&amp; TagLib::ByteVector::setData </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the data for the byte array copies <em>data</em> up to the first null byte. The behavior is undefined if <em>data</em> is not null terminated. </p>

</div>
</div>
<a class="anchor" id="a956f911990decdc396d9d400787687a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TagLib::ByteVector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size of the array. </p>

</div>
</div>
<a class="anchor" id="a5f330306a73bbd23d89f7c14a2126456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TagLib::ByteVector::startsWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>pattern</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vector starts with <em>pattern</em>. </p>

</div>
</div>
<a class="anchor" id="a76dc335731ccb8ef2894ff1b7cdec014"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TagLib::ByteVector::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exchanges the content of the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> by the content of <em>v</em>. </p>

</div>
</div>
<a class="anchor" id="a396653f8c540621a0803ef4fb9ecc771"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::toBase64 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a base64 encoded copy of the byte vector </p>

</div>
</div>
<a class="anchor" id="a8ecc3152b830815587e276308b513791"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TagLib::ByteVector::toFloat32BE </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad6a2142280a5633589915778f54b037a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TagLib::ByteVector::toFloat32LE </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0faf408571471f54fc23014ee0b45ac7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TagLib::ByteVector::toFloat64BE </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a20fea3031e4293fcc798841cf72e0371"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TagLib::ByteVector::toFloat64LE </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a55140a56e23aafd8628209b7a18f3cb7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double TagLib::ByteVector::toFloat80BE </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12ea32224af2025c6d5ae618e4bd2b6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long double TagLib::ByteVector::toFloat80LE </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ae9839e48c11619907ad618a4d7399e76"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::toHex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a hex-encoded copy of the byte vector. </p>

</div>
</div>
<a class="anchor" id="a398ca4acfe99175547dd239a2ed83730"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long TagLib::ByteVector::toLongLong </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 8 bytes of the vector to a (signed) long long.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abae66ba7ba54a1f9aa30a00c2e5ca2ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long long TagLib::ByteVector::toLongLong </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 8 bytes at <em>offset</em> of the vector to a (signed) long long.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 00 00 00 00 00 00 01 == 0x0000000000000001 == 1, if false, $01 00 00 00 00 00 00 00 == 0x0100000000000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a792be96ea5c9edb1d1eb9e987d0f0b1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short TagLib::ByteVector::toShort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 2 bytes of the vector to a (signed) short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a4a7e6c2e922e3c4c0df3fd8524a95c26"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short TagLib::ByteVector::toShort </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 2 bytes at <em>offset</em> of the vector to a (signed) short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8334ff02c963635668cda49410af83ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 4 bytes of the vector to an unsigned integer.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $00 $00 $01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a991a4bece604122c267ccf0022ecfd3c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 4 bytes at <em>offset</em> of the vector to an unsigned integer.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $00 $00 $01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abec14950e616c3fc1b248294f6bc4871"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TagLib::ByteVector::toUInt </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the <em>length</em> bytes at <em>offset</em> of the vector to an unsigned integer. If <em>length</em> is larger than 4, the excess is ignored.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $00 $00 $01 == 0x00000001 == 1, if false, $01 00 00 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a8b8cc9274056ef65cdcfe026843cbfb8">fromUInt()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa504bf38f98c782647ea46fbe7c9dc5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short TagLib::ByteVector::toUShort </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the first 2 bytes of the vector to a unsigned short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a298aa3d114d418de4cf193804526c7a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short TagLib::ByteVector::toUShort </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mostSignificantByteFirst</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the 2 bytes at <em>offset</em> of the vector to a unsigned short.</p>
<p>If <em>mostSignificantByteFirst</em> is true this will operate left to right evaluating the integer. For example if <em>mostSignificantByteFirst</em> is true then $00 $01 == 0x0001 == 1, if false, $01 00 == 0x01000000 == 1.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classTagLib_1_1ByteVector.html#a162543bf4b280468a677799686178522">fromShort()</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a36db251bf327d8f00dcee07367fd7cd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="taglib__export_8h.html#a869a58b518ef871f14a9b4ccfe86ecfb">TAGLIB_EXPORT</a> std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTagLib_1_1ByteVector.html">TagLib::ByteVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Streams the <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> <em>v</em> to the output stream <em>s</em>. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7593a608427eb6f855c4dc48558ad8a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTagLib_1_1ByteVector.html">ByteVector</a> TagLib::ByteVector::null</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static, empty <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a> which is convenient and fast (since returning an empty or "null" value does not require instantiating a new <a class="el" href="classTagLib_1_1ByteVector.html" title="A byte vector. ">ByteVector</a>).</p>
<dl class="section warning"><dt>Warning</dt><dd>Do not modify this variable. It will mess up the internal state of <a class="el" href="namespaceTagLib.html" title="A namespace for all TagLib related classes and functions. ">TagLib</a>.</dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="tbytevector_8h_source.html">tbytevector.h</a></li>
</ul>
</div><!-- contents -->

